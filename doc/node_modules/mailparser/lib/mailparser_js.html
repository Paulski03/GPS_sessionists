<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>mailparser.js - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../../";
  var index_rel_prefix = "../../../";
</script>

<script src="../../../js/jquery.js"></script>
<script src="../../../js/darkfish.js"></script>

<link href="../../../css/fonts.css" rel="stylesheet">
<link href="../../../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../../table_of_contents.html#pages">Pages</a>
    <a href="../../../table_of_contents.html#classes">Classes</a>
    <a href="../../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="../../../Gemfile.html">Gemfile</a>
  
    <li><a href="../../../Gemfile_lock.html">Gemfile.lock</a>
  
    <li><a href="../../../README_md.html">README</a>
  
    <li><a href="../../../Rakefile.html">Rakefile</a>
  
    <li><a href="../../../app/assets/config/manifest_js.html">manifest.js</a>
  
    <li><a href="../../../app/assets/javascripts/application_js.html">application.js</a>
  
    <li><a href="../../../app/assets/javascripts/cable_js.html">cable.js</a>
  
    <li><a href="../../../app/assets/javascripts/pages_coffee.html">pages.coffee</a>
  
    <li><a href="../../../app/assets/stylesheets/application_css_scss.html">application.css.scss</a>
  
    <li><a href="../../../app/assets/stylesheets/custom_css_scss.html">custom.css.scss</a>
  
    <li><a href="../../../app/assets/stylesheets/pages_scss.html">pages.scss</a>
  
    <li><a href="../../../config_ru.html">config.ru</a>
  
    <li><a href="../../../log/development_log.html">development.log</a>
  
    <li><a href="../../../node_modules/addressparser/CHANGELOG_md.html">CHANGELOG</a>
  
    <li><a href="../../../node_modules/addressparser/LICENSE.html">LICENSE</a>
  
    <li><a href="../../../node_modules/addressparser/README_md.html">README</a>
  
    <li><a href="../../../node_modules/addressparser/lib/addressparser_js.html">addressparser.js</a>
  
    <li><a href="../../../node_modules/addressparser/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/async_ensureasync/README_md.html">README</a>
  
    <li><a href="../../../node_modules/async_ensureasync/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/async_ensureasync/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/async_queue/README_md.html">README</a>
  
    <li><a href="../../../node_modules/async_queue/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/async_queue/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/async_util_arrayeach/README_md.html">README</a>
  
    <li><a href="../../../node_modules/async_util_arrayeach/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/async_util_arrayeach/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/async_util_ensureasync/README_md.html">README</a>
  
    <li><a href="../../../node_modules/async_util_ensureasync/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/async_util_ensureasync/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/async_util_isarray/README_md.html">README</a>
  
    <li><a href="../../../node_modules/async_util_isarray/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/async_util_isarray/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/async_util_map/README_md.html">README</a>
  
    <li><a href="../../../node_modules/async_util_map/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/async_util_map/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/async_util_noop/README_md.html">README</a>
  
    <li><a href="../../../node_modules/async_util_noop/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/async_util_noop/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/async_util_onlyonce/README_md.html">README</a>
  
    <li><a href="../../../node_modules/async_util_onlyonce/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/async_util_onlyonce/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/async_util_queue/README_md.html">README</a>
  
    <li><a href="../../../node_modules/async_util_queue/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/async_util_queue/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/async_util_restparam/README_md.html">README</a>
  
    <li><a href="../../../node_modules/async_util_restparam/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/async_util_restparam/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/async_util_setimmediate/README_md.html">README</a>
  
    <li><a href="../../../node_modules/async_util_setimmediate/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/async_util_setimmediate/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/bottleneck/LICENSE.html">LICENSE</a>
  
    <li><a href="../../../node_modules/bottleneck/README_md.html">README</a>
  
    <li><a href="../../../node_modules/bottleneck/bottleneck_d_ts_ejs.html">bottleneck.d.ts.ejs</a>
  
    <li><a href="../../../node_modules/bottleneck/bottleneck_js.html">bottleneck.js</a>
  
    <li><a href="../../../node_modules/bottleneck/bottleneck_min_js.html">bottleneck.min.js</a>
  
    <li><a href="../../../node_modules/bottleneck/bower_json.html">bower.json</a>
  
    <li><a href="../../../node_modules/bottleneck/lib/Bottleneck_js.html">Bottleneck.js</a>
  
    <li><a href="../../../node_modules/bottleneck/lib/Cluster_js.html">Cluster.js</a>
  
    <li><a href="../../../node_modules/bottleneck/lib/DLList_js.html">DLList.js</a>
  
    <li><a href="../../../node_modules/bottleneck/lib/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/bottleneck/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/bottleneck/scripts/build_sh.html">build.sh</a>
  
    <li><a href="../../../node_modules/bottleneck/src/Bottleneck_coffee.html">Bottleneck.coffee</a>
  
    <li><a href="../../../node_modules/bottleneck/src/Cluster_coffee.html">Cluster.coffee</a>
  
    <li><a href="../../../node_modules/bottleneck/src/DLList_coffee.html">DLList.coffee</a>
  
    <li><a href="../../../node_modules/bottleneck/src/index_coffee.html">index.coffee</a>
  
    <li><a href="../../../node_modules/bottleneck/test_ts.html">test.ts</a>
  
    <li><a href="../../../node_modules/bottleneck/test/DLList_js.html">DLList.js</a>
  
    <li><a href="../../../node_modules/bottleneck/test/general_js.html">general.js</a>
  
    <li><a href="../../../node_modules/bottleneck/test/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/bottleneck/test/priority_js.html">priority.js</a>
  
    <li><a href="../../../node_modules/bottleneck/test/promises_js.html">promises.js</a>
  
    <li><a href="../../../node_modules/debug/CHANGELOG_md.html">CHANGELOG</a>
  
    <li><a href="../../../node_modules/debug/LICENSE.html">LICENSE</a>
  
    <li><a href="../../../node_modules/debug/Makefile.html">Makefile</a>
  
    <li><a href="../../../node_modules/debug/README_md.html">README</a>
  
    <li><a href="../../../node_modules/debug/component_json.html">component.json</a>
  
    <li><a href="../../../node_modules/debug/karma_conf_js.html">karma.conf.js</a>
  
    <li><a href="../../../node_modules/debug/node_js.html">node.js</a>
  
    <li><a href="../../../node_modules/debug/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/debug/src/browser_js.html">browser.js</a>
  
    <li><a href="../../../node_modules/debug/src/debug_js.html">debug.js</a>
  
    <li><a href="../../../node_modules/debug/src/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/debug/src/node_js.html">node.js</a>
  
    <li><a href="../../../node_modules/encoding/LICENSE.html">LICENSE</a>
  
    <li><a href="../../../node_modules/encoding/README_md.html">README</a>
  
    <li><a href="../../../node_modules/encoding/lib/encoding_js.html">encoding.js</a>
  
    <li><a href="../../../node_modules/encoding/lib/iconv-loader_js.html">iconv-loader.js</a>
  
    <li><a href="../../../node_modules/encoding/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/encoding/test/test_js.html">test.js</a>
  
    <li><a href="../../../node_modules/extend/CHANGELOG_md.html">CHANGELOG</a>
  
    <li><a href="../../../node_modules/extend/LICENSE.html">LICENSE</a>
  
    <li><a href="../../../node_modules/extend/README_md.html">README</a>
  
    <li><a href="../../../node_modules/extend/component_json.html">component.json</a>
  
    <li><a href="../../../node_modules/extend/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/extend/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/iconv-lite/Changelog_md.html">Changelog</a>
  
    <li><a href="../../../node_modules/iconv-lite/LICENSE.html">LICENSE</a>
  
    <li><a href="../../../node_modules/iconv-lite/README_md.html">README</a>
  
    <li><a href="../../../node_modules/iconv-lite/encodings/dbcs-codec_js.html">dbcs-codec.js</a>
  
    <li><a href="../../../node_modules/iconv-lite/encodings/dbcs-data_js.html">dbcs-data.js</a>
  
    <li><a href="../../../node_modules/iconv-lite/encodings/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/iconv-lite/encodings/internal_js.html">internal.js</a>
  
    <li><a href="../../../node_modules/iconv-lite/encodings/sbcs-codec_js.html">sbcs-codec.js</a>
  
    <li><a href="../../../node_modules/iconv-lite/encodings/sbcs-data-generated_js.html">sbcs-data-generated.js</a>
  
    <li><a href="../../../node_modules/iconv-lite/encodings/sbcs-data_js.html">sbcs-data.js</a>
  
    <li><a href="../../../node_modules/iconv-lite/encodings/tables/big5-added_json.html">big5-added.json</a>
  
    <li><a href="../../../node_modules/iconv-lite/encodings/tables/cp936_json.html">cp936.json</a>
  
    <li><a href="../../../node_modules/iconv-lite/encodings/tables/cp949_json.html">cp949.json</a>
  
    <li><a href="../../../node_modules/iconv-lite/encodings/tables/cp950_json.html">cp950.json</a>
  
    <li><a href="../../../node_modules/iconv-lite/encodings/tables/eucjp_json.html">eucjp.json</a>
  
    <li><a href="../../../node_modules/iconv-lite/encodings/tables/gb18030-ranges_json.html">gb18030-ranges.json</a>
  
    <li><a href="../../../node_modules/iconv-lite/encodings/tables/gbk-added_json.html">gbk-added.json</a>
  
    <li><a href="../../../node_modules/iconv-lite/encodings/tables/shiftjis_json.html">shiftjis.json</a>
  
    <li><a href="../../../node_modules/iconv-lite/encodings/utf16_js.html">utf16.js</a>
  
    <li><a href="../../../node_modules/iconv-lite/encodings/utf7_js.html">utf7.js</a>
  
    <li><a href="../../../node_modules/iconv-lite/lib/bom-handling_js.html">bom-handling.js</a>
  
    <li><a href="../../../node_modules/iconv-lite/lib/extend-node_js.html">extend-node.js</a>
  
    <li><a href="../../../node_modules/iconv-lite/lib/index_d_ts.html">index.d.ts</a>
  
    <li><a href="../../../node_modules/iconv-lite/lib/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/iconv-lite/lib/streams_js.html">streams.js</a>
  
    <li><a href="../../../node_modules/iconv-lite/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/lodash_chunk/LICENSE.html">LICENSE</a>
  
    <li><a href="../../../node_modules/lodash_chunk/README_md.html">README</a>
  
    <li><a href="../../../node_modules/lodash_chunk/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/lodash_chunk/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/mailparser/LICENSE.html">LICENSE</a>
  
    <li><a href="../../../node_modules/mailparser/README_md.html">README</a>
  
    <li><a href="../../../node_modules/mailparser/lib/datetime_js.html">datetime.js</a>
  
    <li><a href="../../../node_modules/mailparser/lib/mailparser_js.html">mailparser.js</a>
  
    <li><a href="../../../node_modules/mailparser/lib/streams_js.html">streams.js</a>
  
    <li><a href="../../../node_modules/mailparser/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/mailparser/test/mailparser_js.html">mailparser.js</a>
  
    <li><a href="../../../node_modules/mailparser/test/mixed_eml.html">mixed.eml</a>
  
    <li><a href="../../../node_modules/mailparser/test/nested_eml.html">nested.eml</a>
  
    <li><a href="../../../node_modules/mime/LICENSE.html">LICENSE</a>
  
    <li><a href="../../../node_modules/mime/README_md.html">README</a>
  
    <li><a href="../../../node_modules/mime/build/build_js.html">build.js</a>
  
    <li><a href="../../../node_modules/mime/build/test_js.html">test.js</a>
  
    <li><a href="../../../node_modules/mime/cli_js.html">cli.js</a>
  
    <li><a href="../../../node_modules/mime/mime_js.html">mime.js</a>
  
    <li><a href="../../../node_modules/mime/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/mime/types_json.html">types.json</a>
  
    <li><a href="../../../node_modules/mimelib/LICENSE.html">LICENSE</a>
  
    <li><a href="../../../node_modules/mimelib/README_md.html">README</a>
  
    <li><a href="../../../node_modules/mimelib/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/mimelib/lib/content-types-reversed_js.html">content-types-reversed.js</a>
  
    <li><a href="../../../node_modules/mimelib/lib/content-types_js.html">content-types.js</a>
  
    <li><a href="../../../node_modules/mimelib/lib/mimelib_js.html">mimelib.js</a>
  
    <li><a href="../../../node_modules/mimelib/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/ms/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/ms/license_md.html">license</a>
  
    <li><a href="../../../node_modules/ms/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/ms/readme_md.html">readme</a>
  
    <li><a href="../../../node_modules/sendgrid-rest/CHANGELOG_md.html">CHANGELOG</a>
  
    <li><a href="../../../node_modules/sendgrid-rest/CONTRIBUTING_md.html">CONTRIBUTING</a>
  
    <li><a href="../../../node_modules/sendgrid-rest/LICENSE_txt.html">LICENSE</a>
  
    <li><a href="../../../node_modules/sendgrid-rest/README_md.html">README</a>
  
    <li><a href="../../../node_modules/sendgrid-rest/examples/example_js.html">example.js</a>
  
    <li><a href="../../../node_modules/sendgrid-rest/lib/client_js.html">client.js</a>
  
    <li><a href="../../../node_modules/sendgrid-rest/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/sendgrid-rest/test/test_js.html">test.js</a>
  
    <li><a href="../../../node_modules/sendgrid/CHANGELOG_md.html">CHANGELOG</a>
  
    <li><a href="../../../node_modules/sendgrid/CONTRIBUTING_md.html">CONTRIBUTING</a>
  
    <li><a href="../../../node_modules/sendgrid/LICENSE_txt.html">LICENSE</a>
  
    <li><a href="../../../node_modules/sendgrid/README_md.html">README</a>
  
    <li><a href="../../../node_modules/sendgrid/TROUBLESHOOTING_md.html">TROUBLESHOOTING</a>
  
    <li><a href="../../../node_modules/sendgrid/USAGE_md.html">USAGE</a>
  
    <li><a href="../../../node_modules/sendgrid/USE_CASES_md.html">USE_CASES</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/accesssettings/accesssettings_js.html">accesssettings.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/alerts/alerts_js.html">alerts.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/apikeys/apikeys_js.html">apikeys.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/asm/asm_js.html">asm.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/browsers/browsers_js.html">browsers.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/campaigns/campaigns_js.html">campaigns.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/categories/categories_js.html">categories.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/clients/clients_js.html">clients.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/contactdb/contactdb_js.html">contactdb.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/devices/devices_js.html">devices.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/geo/geo_js.html">geo.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/helpers/mail/example_js.html">example.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/ips/ips_js.html">ips.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/mail/mail_js.html">mail.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/mailboxproviders/mailboxproviders_js.html">mailboxproviders.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/mailsettings/mailsettings_js.html">mailsettings.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/partnersettings/partnersettings_js.html">partnersettings.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/scopes/scopes_js.html">scopes.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/senders/senders_js.html">senders.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/stats/stats_js.html">stats.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/subusers/subusers_js.html">subusers.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/suppression/suppression_js.html">suppression.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/templates/templates_js.html">templates.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/trackingsettings/trackingsettings_js.html">trackingsettings.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/user/user_js.html">user.js</a>
  
    <li><a href="../../../node_modules/sendgrid/examples/whitelabel/whitelabel_js.html">whitelabel.js</a>
  
    <li><a href="../../../node_modules/sendgrid/index_d_ts.html">index.d.ts</a>
  
    <li><a href="../../../node_modules/sendgrid/index_js.html">index.js</a>
  
    <li><a href="../../../node_modules/sendgrid/lib/helpers/contact-importer/contact-importer_js.html">contact-importer.js</a>
  
    <li><a href="../../../node_modules/sendgrid/lib/helpers/error_js.html">error.js</a>
  
    <li><a href="../../../node_modules/sendgrid/lib/helpers/inbound/parse_js.html">parse.js</a>
  
    <li><a href="../../../node_modules/sendgrid/lib/helpers/mail/README_md.html">README</a>
  
    <li><a href="../../../node_modules/sendgrid/lib/helpers/mail/mail_js.html">mail.js</a>
  
    <li><a href="../../../node_modules/sendgrid/lib/sendgrid_js.html">sendgrid.js</a>
  
    <li><a href="../../../node_modules/sendgrid/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/sendgrid/test/helpers/contact-importer/contact-importer_test_js.html">contact-importer.test.js</a>
  
    <li><a href="../../../node_modules/sendgrid/test/helpers/inbound/parse_test_js.html">parse.test.js</a>
  
    <li><a href="../../../node_modules/sendgrid/test/helpers/mail/test_js.html">test.js</a>
  
    <li><a href="../../../node_modules/sendgrid/test/prism_sh.html">prism.sh</a>
  
    <li><a href="../../../node_modules/sendgrid/test/test_js.html">test.js</a>
  
    <li><a href="../../../node_modules/sendgrid/tsconfig_json.html">tsconfig.json</a>
  
    <li><a href="../../../node_modules/uue/LICENSE.html">LICENSE</a>
  
    <li><a href="../../../node_modules/uue/README_md.html">README</a>
  
    <li><a href="../../../node_modules/uue/package_json.html">package.json</a>
  
    <li><a href="../../../node_modules/uue/uue_js.html">uue.js</a>
  
    <li><a href="../../../package-lock_json.html">package-lock.json</a>
  
    <li><a href="../../../package_json.html">package.json</a>
  
    <li><a href="../../../public/404_html.html">404.html</a>
  
    <li><a href="../../../public/422_html.html">422.html</a>
  
    <li><a href="../../../public/500_html.html">500.html</a>
  
    <li><a href="../../../public/apple-touch-icon-precomposed_png.html">apple-touch-icon-precomposed.png</a>
  
    <li><a href="../../../public/apple-touch-icon_png.html">apple-touch-icon.png</a>
  
    <li><a href="../../../public/favicon_ico.html">favicon.ico</a>
  
    <li><a href="../../../public/robots_txt.html">robots</a>
  
    <li><a href="../../../tmp/pids/server_pid.html">server.pid</a>
  
    <li><a href="../../../tmp/restart_txt.html">restart</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page node_modules/mailparser/lib/mailparser.js">

<p>“use strict”;</p>

<pre>@fileOverview This is the main file for the MailParser library to parse raw e-mail data
@author &lt;a href=&quot;mailto:andris@node.ee&quot;&gt;Andris Reinman&lt;/a&gt;
@version 0.2.23</pre>

<p>var Stream = require(“stream”).Stream,</p>

<pre class="ruby"><span class="ruby-identifier">utillib</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&quot;util&quot;</span>),
<span class="ruby-identifier">mimelib</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&quot;mimelib&quot;</span>),
<span class="ruby-identifier">datetime</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&quot;./datetime&quot;</span>),
<span class="ruby-identifier">encodinglib</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&quot;encoding&quot;</span>),
<span class="ruby-constant">Streams</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&quot;./streams&quot;</span>),
<span class="ruby-identifier">crypto</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&quot;crypto&quot;</span>),
<span class="ruby-identifier">mime</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&quot;mime&quot;</span>);
</pre>

<p>// Expose to the world module.exports.MailParser = MailParser;</p>

<p>// MailParser is a FSM - it is always in one of the possible states var
STATES = {</p>

<pre>header: 0x1,
body: 0x2,
finished: 0x3</pre>

<p>};</p>

<pre> &lt;p&gt;Creates instance of MailParser which in turn extends Stream&lt;/p&gt;

 &lt;p&gt;Options object has the following properties:&lt;/p&gt;

 &lt;ul&gt;
   &lt;li&gt;&lt;b&gt;debug&lt;/b&gt; - if set to true print all incoming lines to decodeq&lt;/li&gt;
   &lt;li&gt;&lt;b&gt;streamAttachments&lt;/b&gt; - if set to true, stream attachments instead of including them&lt;/li&gt;
   &lt;li&gt;&lt;b&gt;unescapeSMTP&lt;/b&gt; - if set to true replace double dots in the beginning of the file&lt;/li&gt;
   &lt;li&gt;&lt;b&gt;defaultCharset&lt;/b&gt; - the default charset for text/plain, text/html content, if not set reverts to Latin-1
   &lt;li&gt;&lt;b&gt;showAttachmentLinks&lt;/b&gt;&lt;/li&gt; - if set to true, show inlined attachment links
 &lt;/ul&gt;

 @constructor
 @param {Object} [options] Optional options object
/</pre>

<p>function MailParser(options) {</p>

<pre>// Make MailParser a Stream object
Stream.call(this);
this.writable = true;

/**
   Options object
   @public    
this.options = options || {};

/**
   Indicates current state the parser is in
   @private */
this._state = STATES.header;

/**
   The remaining data from the previos chunk which is waiting to be processed
   @private */
this._remainder = &quot;&quot;;

/**
   The complete tree structure of the e-mail
   @public  */
this.mimeTree = this._createMimeNode();

/**
   Current node of the multipart mime tree that is being processed
   @private */
this._currentNode = this.mimeTree;

// default values for the root node
this._currentNode.priority = &quot;normal&quot;;

/**
   An object of already used attachment filenames
   @private */
this._fileNames = {};

/**
   An array of multipart nodes
   @private */
this._multipartTree = [];

/**
   This is the final mail structure object that is returned to the client
   @public  */
this.mailData = {};

/**
   Line counter for debugging
   @private */
this._lineCounter = 0;

/**
   Did the last chunk end with \r
   @private */
this._lineFeed = false;

/**
   Is the &quot;headers&quot; event already emitted
   @private */
this._headersSent = false;

/**
   If the e-mail is in mbox format, unescape &quot;&gt;From &quot; to &quot;From &quot; in body
   @private */
this._isMbox = -1;</pre>

<p>} // inherit methods and properties of Stream utillib.inherits(MailParser,
Stream);</p>

<p>/**</p>

<pre> &lt;p&gt;Writes a value to the MailParser stream&lt;p&gt;

 @param {Buffer|String} chunk The data to be written to the MailParser stream
 @param {String} [encoding] The encoding to be used when &quot;chunk&quot; is a string
 @returns {Boolean} Returns true
/</pre>

<p>MailParser.prototype.write = function(chunk, encoding) {</p>

<pre>if (this._write(chunk, encoding)) {
    if (typeof setImmediate == &quot;function&quot;) {
        setImmediate(this._process.bind(this));
    } else {
        process.nextTick(this._process.bind(this));
    }
}
return true;</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Terminates the MailParser stream&lt;/p&gt;

 &lt;p&gt;If &quot;chunk&quot; is set, writes it to the Stream before terminating.&lt;/p&gt;

 @param {Buffer|String} chunk The data to be written to the MailParser stream
 @param {String} [encoding] The encoding to be used when &quot;chunk&quot; is a string
/</pre>

<p>MailParser.prototype.end = function(chunk, encoding) {</p>

<pre>this._write(chunk, encoding);

if (this.options.debug &amp;&amp; this._remainder) {
    console.log(&quot;REMAINDER: &quot; + this._remainder);
}

if (typeof setImmediate == &quot;function&quot;) {
    setImmediate(this._process.bind(this, true));
} else {
    process.nextTick(this._process.bind(this, true));
}</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Normalizes CRLF&#39;s before writing to the Mailparser stream, does &lt;i&gt;not&lt;/i&gt; call `_process`&lt;p&gt;

 @param {Buffer|String} chunk The data to be written to the MailParser stream
 @param {String} [encoding] The encoding to be used when &quot;chunk&quot; is a string
 @returns {Boolean} Returns true if writing the chunk was successful
/</pre>

<p>MailParser.prototype._write = function(chunk, encoding) {</p>

<pre>if (typeof chunk == &quot;string&quot;) {
    chunk = new Buffer(chunk, encoding);
}

chunk = chunk &amp;&amp; chunk.toString(&quot;binary&quot;) || &quot;&quot;;

// if the last chunk ended with \r and this one begins
// with \n, it&#39;s a split line ending. Since the last \r
// was already used, skip the \n
if (this._lineFeed &amp;&amp; chunk.charAt(0) === &quot;\n&quot;) {
    chunk = chunk.substr(1);
}
this._lineFeed = chunk.substr(-1) === &quot;\r&quot;;

if (chunk &amp;&amp; chunk.length) {
    this._remainder += chunk;
    return true;
}
return false;</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Processes the data written to the MailParser stream&lt;/p&gt;

 &lt;p&gt;The data is split into lines and each line is processed individually. Last
 line in the batch is preserved as a remainder since it is probably not a
 complete line but just the beginning of it. The remainder is later prepended
 to the next batch of data.&lt;/p&gt;

 @param {Boolean} [finalPart=false] if set to true indicates that this is the last part of the stream
/</pre>

<p>MailParser.prototype._process = function(finalPart) {</p>

<pre>finalPart = !!finalPart;
var lines = this._remainder.split(/\r?\n|\r/),
    line, i, len;

if (!finalPart) {
    this._remainder = lines.pop();
    // force line to 1MB chunks if needed
    if (this._remainder.length &gt; 1048576) {
        this._remainder = this._remainder.replace(/(.{1048576}(?!\r?\n|\r))/g, &quot;$&amp;\n&quot;);
    }
}

for (i = 0, len = lines.length; i &lt; len; i++) {
    line = lines[i];

    if (this.options.unescapeSMTP &amp;&amp; line.substr(0, 2) == &quot;..&quot;) {
        line = line.substr(1);
    }

    if (this._isMbox === true &amp;&amp; line.match(/^\&gt;+From /)) {
        line = line.substr(1);
    }

    if (this.options.debug) {
        console.log(&quot;LINE &quot; + (++this._lineCounter) + &quot; (&quot; + this._state + &quot;): &quot; + line);
    }

    if (this._state == STATES.header) {
        if (this._processStateHeader(line) === true) {
            continue;
        }
    }

    if (this._state == STATES.body) {
        if (this._processStateBody(line) === true) {
            continue;
        }
    }
}
if (finalPart) {
    if (this._state == STATES.header &amp;&amp; this._remainder) {
        this._processStateHeader(this._remainder);
        if (!this._headersSent) {
            this.emit(&quot;headers&quot;, this._currentNode.parsedHeaders);
            this._headersSent = true;
        }
    }
    if (this._currentNode.content || this._currentNode.stream) {
        this._finalizeContents();
    }
    this._state = STATES.finished;
    if (typeof setImmediate == &quot;function&quot;) {
        setImmediate(this._processMimeTree.bind(this));
    } else {
        process.nextTick(this._processMimeTree.bind(this));
    }
}</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Processes a line while in header state&lt;/p&gt;

 &lt;p&gt;If header state ends and body starts, detect if the contents is an attachment
 and create a stream for it if needed&lt;/p&gt;

 @param {String} line The contents of a line to be processed
 @returns {Boolean} If state changes to body retuns true
/</pre>

<p>MailParser.prototype._processStateHeader = function(line) {</p>

<pre>var attachment, lastPos = this._currentNode.headers.length - 1,
    textContent = false,
    rootNode,
    extension;

// Check if the header ends and body starts
if (!line.length) {
    if (lastPos &gt;= 0) {
        this._processHeaderLine(lastPos);
    }
    if (!this._headersSent) {
        this.emit(&quot;headers&quot;, this._currentNode.parsedHeaders);
        this._headersSent = true;
    }

    this._state = STATES.body;

    // if there&#39;s unprocessed header data, do it now
    if (lastPos &gt;= 0) {
        this._processHeaderLine(lastPos);
    }

    // this is a very simple e-mail, no content type set
    if (!this._currentNode.parentNode &amp;&amp; !this._currentNode.meta.contentType) {
        this._currentNode.meta.contentType = &quot;text/plain&quot;;
    }

    textContent = [&quot;text/plain&quot;, &quot;text/html&quot;, &quot;text/calendar&quot;].indexOf(this._currentNode.meta.contentType || &quot;&quot;) &gt;= 0;

    // detect if this is an attachment or a text node (some agents use inline dispositions for text)
    if (textContent &amp;&amp; (!this._currentNode.meta.contentDisposition || this._currentNode.meta.contentDisposition == &quot;inline&quot;)) {
        this._currentNode.attachment = false;
    } else if ((!textContent || [&quot;attachment&quot;, &quot;inline&quot;].indexOf(this._currentNode.meta.contentDisposition) &gt;= 0) &amp;&amp;
        !this._currentNode.meta.mimeMultipart) {
        this._currentNode.attachment = true;
    }

    // handle attachment start
    if (this._currentNode.attachment) {

        this._currentNode.meta.generatedFileName = this._generateFileName(this._currentNode.meta.fileName, this._currentNode.meta.contentType);

        this._currentNode.meta.contentId = this._currentNode.meta.contentId ||
            crypto.createHash(&quot;md5&quot;).update(new Buffer(this._currentNode.meta.generatedFileName, &#39;utf-8&#39;)).digest(&quot;hex&quot;) + &quot;@mailparser&quot;;

        extension = this._currentNode.meta.generatedFileName.split(&quot;.&quot;).pop().toLowerCase();

        // Update content-type if it&#39;s an application/octet-stream and file extension is available
        if (this._currentNode.meta.contentType == &quot;application/octet-stream&quot; &amp;&amp; mime.lookup(extension)) {
            this._currentNode.meta.contentType = mime.lookup(extension);
        }

        attachment = this._currentNode.meta;
        if (this.options.streamAttachments) {
            if (this._currentNode.meta.transferEncoding == &quot;base64&quot;) {
                this._currentNode.stream = new Streams.Base64Stream();
            } else if (this._currentNode.meta.transferEncoding == &quot;quoted-printable&quot;) {
                this._currentNode.stream = new Streams.QPStream(&quot;binary&quot;);
            } else if (this._currentNode.meta.transferEncoding == &quot;uuencode&quot;) {
                this._currentNode.stream = new Streams.UUEStream(&quot;binary&quot;);
            } else {
                this._currentNode.stream = new Streams.BinaryStream();
            }
            attachment.stream = this._currentNode.stream;

            rootNode = this._currentNode;

            while (rootNode.parentNode) {
                rootNode = rootNode.parentNode;
            }

            this.emit(&quot;attachment&quot;, attachment, rootNode);
        } else {
            this._currentNode.content = undefined;
        }
    }

    return true;
}

// unfold header lines if needed
if (line.match(/^\s+/) &amp;&amp; lastPos &gt;= 0) {
    this._currentNode.headers[lastPos] += &quot; &quot; + line.trim();
} else {
    this._currentNode.headers.push(line.trim());
    if (lastPos &gt;= 0) {
        // if a complete header line is received, process it
        this._processHeaderLine(lastPos);
    }
}

return false;</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Processes a line while in body state&lt;/p&gt;

 @param {String} line The contents of a line to be processed
 @returns {Boolean} If body ends return true
/</pre>

<p>MailParser.prototype._processStateBody = function(line) {</p>

<pre>var i, len, node,
    nodeReady = false;

// Handle multipart boundaries
if (line.substr(0, 2) == &quot;--&quot;) {
    for (i = 0, len = this._multipartTree.length; i &lt; len; i++) {

        // check if a new element block starts
        if (line == &quot;--&quot; + this._multipartTree[i].boundary) {

            if (this._currentNode.content || this._currentNode.stream) {
                this._finalizeContents();
            }

            node = this._createMimeNode(this._multipartTree[i].node);
            this._multipartTree[i].node.childNodes.push(node);
            this._currentNode = node;
            this._state = STATES.header;
            nodeReady = true;
            break;
        } else
        // check if a multipart block ends
        if (line == &quot;--&quot; + this._multipartTree[i].boundary + &quot;--&quot;) {

            if (this._currentNode.content || this._currentNode.stream) {
                this._finalizeContents();
            }

            if (this._multipartTree[i].node.parentNode) {
                this._currentNode = this._multipartTree[i].node.parentNode;
            } else {
                this._currentNode = this._multipartTree[i].node;
            }
            this._state = STATES.body;
            nodeReady = true;
            break;
        }
    }
}
if (nodeReady) {
    return true;
}

// handle text or attachment line
if ([&quot;text/plain&quot;, &quot;text/html&quot;, &quot;text/calendar&quot;].indexOf(this._currentNode.meta.contentType || &quot;&quot;) &gt;= 0 &amp;&amp;
    !this._currentNode.attachment) {
    this._handleTextLine(line);
} else if (this._currentNode.attachment) {
    this._handleAttachmentLine(line);
}

return false;</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Processes a complete unfolded header line&lt;/p&gt;

 &lt;p&gt;Processes a line from current node headers array and replaces its value.
 Input string is in the form of &quot;X-Mailer: PHP&quot; and its replacement would be
 an object &lt;code&gt;{key: &quot;x-mailer&quot;, value: &quot;PHP&quot;}&lt;/code&gt;&lt;/p&gt;

 &lt;p&gt;Additionally node meta object will be filled also, for example with data from
 To: From: Cc: etc fields.&lt;/p&gt;

 @param {Number} pos Which header element (from an header lines array) should be processed
/</pre>

<p>MailParser.prototype._processHeaderLine = function(pos) {</p>

<pre>var key, value, parts, line;

pos = pos || 0;

if (!(line = this._currentNode.headers[pos]) || typeof line != &quot;string&quot;) {
    return;
}

if (!this._headersSent &amp;&amp; this._isMbox &lt; 0) {
    if ((this._isMbox = !!line.match(/^From /))) {
        return;
    }
}

parts = line.split(&quot;:&quot;);

key = parts.shift().toLowerCase().trim();
value = parts.join(&quot;:&quot;).trim();

switch (key) {
    case &quot;content-type&quot;:
        this._parseContentType(value);
        break;
    case &quot;mime-version&quot;:
        this._currentNode.useMIME = true;
        break;
    case &quot;date&quot;:
        this._currentNode.meta.date = this._parseDateString(value);
        break;
    case &quot;received&quot;:
    case &quot;x-received&quot;:
        this._parseReceived(value);
        break;
    case &quot;to&quot;:
        if (this._currentNode.to &amp;&amp; this._currentNode.to.length) {
            this._currentNode.to = this._currentNode.to.concat(mimelib.parseAddresses(value));
        } else {
            this._currentNode.to = mimelib.parseAddresses(value);
        }
        break;
    case &quot;from&quot;:
        if (this._currentNode.from &amp;&amp; this._currentNode.from.length) {
            this._currentNode.from = this._currentNode.from.concat(mimelib.parseAddresses(value));
        } else {
            this._currentNode.from = mimelib.parseAddresses(value);
        }
        break;
    case &quot;reply-to&quot;:
        if (this._currentNode.replyTo &amp;&amp; this._currentNode.replyTo.length) {
            this._currentNode.replyTo = this._currentNode.replyTo.concat(mimelib.parseAddresses(value));
        } else {
            this._currentNode.replyTo = mimelib.parseAddresses(value);
        }
        break;
    case &quot;cc&quot;:
        if (this._currentNode.cc &amp;&amp; this._currentNode.cc.length) {
            this._currentNode.cc = this._currentNode.cc.concat(mimelib.parseAddresses(value));
        } else {
            this._currentNode.cc = mimelib.parseAddresses(value);
        }
        break;
    case &quot;bcc&quot;:
        if (this._currentNode.bcc &amp;&amp; this._currentNode.bcc.length) {
            this._currentNode.bcc = this._currentNode.bcc.concat(mimelib.parseAddresses(value));
        } else {
            this._currentNode.bcc = mimelib.parseAddresses(value);
        }
        break;
    case &quot;x-priority&quot;:
    case &quot;x-msmail-priority&quot;:
    case &quot;importance&quot;:
        value = this._parsePriority(value);
        this._currentNode.priority = value;
        break;
    case &quot;message-id&quot;:
        this._currentNode.meta.messageId = this._trimQuotes(value);
        this._currentNode.messageId = this._currentNode.meta.messageId;
        break;
    case &quot;references&quot;:
        this._parseReferences(value);
        break;
    case &quot;in-reply-to&quot;:
        this._parseInReplyTo(value);
        break;
    case &quot;thread-index&quot;:
        this._currentNode.meta.threadIndex = value;
        break;
    case &quot;content-transfer-encoding&quot;:
        this._currentNode.meta.transferEncoding = value.toLowerCase();
        break;
    case &quot;content-location&quot;:
        this._currentNode.meta.location = value.toLowerCase();
        break;
    case &quot;subject&quot;:
        this._currentNode.subject = this._encodeString(value);
        break;
    case &quot;content-disposition&quot;:
        this._parseContentDisposition(value);
        break;
    case &quot;content-id&quot;:
        this._currentNode.meta.contentId = this._trimQuotes(value);
        break;
}

if (this._currentNode.parsedHeaders[key]) {
    if (!Array.isArray(this._currentNode.parsedHeaders[key])) {
        this._currentNode.parsedHeaders[key] = [this._currentNode.parsedHeaders[key]];
    }
    this._currentNode.parsedHeaders[key].push(this._replaceMimeWords(value));
} else {
    this._currentNode.parsedHeaders[key] = this._replaceMimeWords(value);
}

this._currentNode.headers[pos] = {
    key: key,
    value: value
};</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Creates an empty node element for the mime tree&lt;/p&gt;

 &lt;p&gt;Created element includes parentNode property and a childNodes array. This is
 needed to later walk the whole mime tree&lt;/p&gt;

 @param {Object} [parentNode] the parent object for the created node
 @returns {Object} node element for the mime tree
/</pre>

<p>MailParser.prototype._createMimeNode = function(parentNode) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">node</span> = {
    <span class="ruby-identifier">parentNode</span><span class="ruby-operator">:</span> <span class="ruby-identifier">parentNode</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_currentNode</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">null</span>,
    <span class="ruby-identifier">headers</span><span class="ruby-operator">:</span> [],
    <span class="ruby-identifier">parsedHeaders</span><span class="ruby-operator">:</span> {},
    <span class="ruby-identifier">meta</span><span class="ruby-operator">:</span> {},
    <span class="ruby-identifier">childNodes</span><span class="ruby-operator">:</span> []
};

<span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>;
</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Splits a header value into key-value pairs&lt;/p&gt;

 &lt;p&gt;Splits on &lt;code&gt;;&lt;/code&gt; - the first value will be set as &lt;code&gt;defaultValue&lt;/code&gt; property and will
 not be handled, others will be split on &lt;code&gt;=&lt;/code&gt; to key-value pairs&lt;/p&gt;

 &lt;p&gt;For example &lt;code&gt;content-type: text/plain; charset=utf-8&lt;/code&gt; will become:&lt;/p&gt;

 &lt;pre&gt;
 {
     defaultValue: &quot;text/plain&quot;,
     charset: &quot;utf-8&quot;
 }
 &lt;/pre&gt;

 @param {String} value A string to be splitted into key-value pairs
 @returns {Object} a key-value object, with defaultvalue property
/</pre>

<p>MailParser.prototype._parseHeaderLineWithParams = function(value) {</p>

<pre>var key, parts, returnValue = {};

parts = value.match(/(?:[^;&quot;]+|&quot;[^&quot;]*&quot;)+/g) || [value];
returnValue.defaultValue = parts.shift().toLowerCase();

for (var i = 0, len = parts.length; i &lt; len; i++) {
    value = parts[i].split(&quot;=&quot;);
    key = value.shift().trim().toLowerCase();
    value = value.join(&quot;=&quot;).trim();

    // trim quotes
    value = this._trimQuotes(value);
    returnValue[key] = value;
}

return returnValue;</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Parses date string&lt;/o&gt;

 &lt;p&gt;Receives possible date string in different formats and
 transforms it into a JS Date object&lt;/p&gt;

 @param {String} value possible date string
 @returns {Date|Boolean} date object
/</pre>

<p>MailParser.prototype._parseDateString = function(value) {</p>

<pre>var date;

date = new Date(value);
if (Object.prototype.toString.call(date) != &quot;[object Date]&quot; || date.toString() == &quot;Invalid Date&quot;) {
    try {
        date = datetime.strtotime(value);
    } catch (E) {
        return false;
    }
    if (date) {
        date = new Date(date * 1000);
    } else {
        return false;
    }
}

return date;</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Parses Received and X-Received header field value&lt;/p&gt;

 &lt;p&gt;Pulls received date from the received and x-received header fields and
 update current node meta object with this date as long as it&#39;s later as the
 existing date of the meta object&lt;/p&gt;

 &lt;p&gt;Example: &lt;code&gt;by 10.25.25.72 with SMTP id 69csp2404548lfz; Fri, 6 Feb 2015 15:15:32 -0800 (PST)&lt;/code&gt;
 will become:
 &lt;/p&gt;

 &lt;pre&gt;new Date(&#39;2015-02-06T23:15:32.000Z&#39;)&lt;/pre&gt;

 @param {String} value Received string
 @returns {Date|Boolean} parsed received date
/</pre>

<p>MailParser.prototype._parseReceived = function(value) {</p>

<pre>var receivedDate, date, splitString;
if (!value) {
    return false;
}

splitString = value.split(&#39;;&#39;);
value = splitString[splitString.length - 1];

date = this._parseDateString(value);
receivedDate = this._currentNode.meta.receivedDate;

if (!date) {
    if (!receivedDate) {
        this._currentNode.meta.receivedDate = date;
    }
    return date;
}

if (!receivedDate) {
    this._currentNode.meta.receivedDate = date;
} else if (date &gt; receivedDate) {
    this._currentNode.meta.receivedDate = date;
}

return date;</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Parses a Content-Type header field value&lt;/p&gt;

 &lt;p&gt;Fetches additional properties from the content type (charset etc.) and fills
 current node meta object with this data&lt;/p&gt;

 @param {String} value Content-Type string
 @returns {Object} parsed contenttype object
/</pre>

<p>MailParser.prototype._parseContentType = function(value) {</p>

<pre>var fileName;
value = this._parseHeaderLineWithParams(value);
if (value) {
    if (value.defaultValue) {
        value.defaultValue = value.defaultValue.toLowerCase();
        this._currentNode.meta.contentType = value.defaultValue;
        if (value.defaultValue.substr(0, &quot;multipart/&quot;.length) == &quot;multipart/&quot;) {
            this._currentNode.meta.mimeMultipart = value.defaultValue.substr(&quot;multipart/&quot;.length);
        }
    } else {
        this._currentNode.meta.contentType = &quot;application/octet-stream&quot;;
    }
    if (value.charset) {
        value.charset = value.charset.toLowerCase();
        if (value.charset.substr(0, 4) == &quot;win-&quot;) {
            value.charset = &quot;windows-&quot; + value.charset.substr(4);
        } else if (value.charset == &quot;ks_c_5601-1987&quot;) {
            value.charset = &quot;cp949&quot;;
        } else if (value.charset.match(/^utf\d/)) {
            value.charset = &quot;utf-&quot; + value.charset.substr(3);
        } else if (value.charset.match(/^latin[\-_]?\d/)) {
            value.charset = &quot;iso-8859-&quot; + value.charset.replace(/\D/g, &quot;&quot;);
        } else if (value.charset.match(/^(us\-)?ascii$/)) {
            value.charset = &quot;utf-8&quot;;
        } else if (value.charset.match(/^ansi_x3\.4\-19/)) {
            // ANSI_X3.4-1968 and ANSI_X3.4-1986 are aliases for ASCII.
            // See http://en.wikipedia.org/wiki/ASCII#Aliases
            value.charset = &quot;utf-8&quot;;
        }
        this._currentNode.meta.charset = value.charset;
    }
    if (value.format) {
        this._currentNode.meta.textFormat = value.format.toLowerCase();
    }
    if (value.delsp) {
        this._currentNode.meta.textDelSp = value.delsp.toLowerCase();
    }
    if (value.boundary) {
        this._currentNode.meta.mimeBoundary = value.boundary;
    }

    if (value.method) {
        this._currentNode.meta.method = value.method;
    }

    if (!this._currentNode.meta.fileName &amp;&amp; (fileName = this._detectFilename(value))) {
        this._currentNode.meta.fileName = fileName;
    }

    if (value.boundary) {
        this._currentNode.meta.mimeBoundary = value.boundary;
        this._multipartTree.push({
            boundary: value.boundary,
            node: this._currentNode
        });
    }
}
return value;</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Parses file name from a Content-Type or Content-Disposition field&lt;/p&gt;

 &lt;p&gt;Supports &lt;a href=&quot;http://tools.ietf.org/html/rfc2231&quot;&gt;RFC2231&lt;/a&gt; for
 folded filenames&lt;/p&gt;

 @param {Object} value Parsed Content-(Type|Disposition) object
 @return {String} filename
/</pre>

<p>MailParser.prototype._detectFilename = function(value) {</p>

<pre>var fileName = &quot;&quot;,
    i = 0,
    parts, encoding, name, part;

if (value.name) {
    return this._replaceMimeWords(value.name);
}

if (value.filename) {
    return this._replaceMimeWords(value.filename);
}

// RFC2231
if (value[&quot;name*&quot;]) {
    fileName = value[&quot;name*&quot;];
} else if (value[&quot;filename*&quot;]) {
    fileName = value[&quot;filename*&quot;];
} else if (value[&quot;name*0*&quot;] || value[&quot;name*0&quot;]) {
    while ((part = (value[&quot;name*&quot; + (i) + &quot;*&quot;] || value[&quot;name*&quot; + (i)]))) {
        fileName += part;
        i++;
    }
} else if (value[&quot;filename*0*&quot;] || value[&quot;filename*0&quot;]) {
    while ((part = (value[&quot;filename*&quot; + (i) + &quot;*&quot;] || value[&quot;filename*&quot; + (i)]))) {
        fileName += part;
        i++;
    }
}

if (fileName) {
    parts = fileName.split(&quot;&#39;&quot;);
    encoding = (parts.length &gt; 1) ? parts[0] : &quot;us-ascii&quot;;
    name = parts.pop();
    if (name) {
        return this._replaceMimeWords(this._replaceMimeWords(&quot;=?&quot; + encoding + &quot;?Q?&quot; + name.replace(/%/g, &quot;=&quot;) + &quot;?=&quot;));
    }
}
return &quot;&quot;;</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Parses Content-Disposition header field value&lt;/p&gt;

 &lt;p&gt;Fetches filename to current node meta object&lt;/p&gt;

 @param {String} value A Content-Disposition header field
/</pre>

<p>MailParser.prototype._parseContentDisposition = function(value) {</p>

<pre>var fileName;

value = this._parseHeaderLineWithParams(value);

if (value) {
    if (value.defaultValue) {
        this._currentNode.meta.contentDisposition = value.defaultValue.trim().toLowerCase();
    }
    if ((fileName = this._detectFilename(value))) {
        this._currentNode.meta.fileName = fileName;
    }
}</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Parses &quot;References&quot; header&lt;/p&gt;

 @param {String} value References header field
/</pre>

<p>MailParser.prototype._parseReferences = function(value) {</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">_currentNode</span>.<span class="ruby-identifier">references</span> = (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">_currentNode</span>.<span class="ruby-identifier">references</span> <span class="ruby-operator">||</span> []).<span class="ruby-identifier">concat</span>(
    (<span class="ruby-identifier">value</span> <span class="ruby-operator">||</span> <span class="ruby-string">&quot;&quot;</span>).<span class="ruby-identifier">toString</span>().<span class="ruby-identifier">trim</span>().<span class="ruby-identifier">split</span>(<span class="ruby-regexp">/\s+/</span>).<span class="ruby-identifier">map</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">_trimQuotes</span>.<span class="ruby-identifier">bind</span>(<span class="ruby-identifier">this</span>))
);
</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Parses &quot;In-Reply-To&quot; header&lt;/p&gt;

 @param {String} value In-Reply-To header field
/</pre>

<p>MailParser.prototype._parseInReplyTo = function(value) {</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">_currentNode</span>.<span class="ruby-identifier">inReplyTo</span> = (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">_currentNode</span>.<span class="ruby-identifier">inReplyTo</span> <span class="ruby-operator">||</span> []).<span class="ruby-identifier">concat</span>(
    (<span class="ruby-identifier">value</span> <span class="ruby-operator">||</span> <span class="ruby-string">&quot;&quot;</span>).<span class="ruby-identifier">toString</span>().<span class="ruby-identifier">trim</span>().<span class="ruby-identifier">split</span>(<span class="ruby-regexp">/\s+/</span>).<span class="ruby-identifier">map</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">_trimQuotes</span>.<span class="ruby-identifier">bind</span>(<span class="ruby-identifier">this</span>))
);
</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Parses the priority of the e-mail&lt;/p&gt;

 @param {String} value The priority value
 @returns {String} priority string low|normal|high
/</pre>

<p>MailParser.prototype._parsePriority = function(value) {</p>

<pre>value = value.toLowerCase().trim();
if (!isNaN(parseInt(value, 10))) { // support &quot;X-Priority: 1 (Highest)&quot;
    value = parseInt(value, 10) || 0;
    if (value == 3) {
        return &quot;normal&quot;;
    } else if (value &gt; 3) {
        return &quot;low&quot;;
    } else {
        return &quot;high&quot;;
    }
} else {
    switch (value) {
        case &quot;non-urgent&quot;:
        case &quot;low&quot;:
            return &quot;low&quot;;
        case &quot;urgent&quot;:
        case &quot;high&quot;:
            return &quot;high&quot;;
    }
}
return &quot;normal&quot;;</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Processes a line in text/html or text/plain node&lt;/p&gt;

 &lt;p&gt;Append the line to the content property&lt;/p&gt;

 @param {String} line A line to be processed
/</pre>

<p>MailParser.prototype._handleTextLine = function(line) {</p>

<pre>if ([&quot;quoted-printable&quot;, &quot;base64&quot;].indexOf(this._currentNode.meta.transferEncoding) &gt;= 0 || this._currentNode.meta.textFormat != &quot;flowed&quot;) {
    if (typeof this._currentNode.content != &quot;string&quot;) {
        this._currentNode.content = line;
    } else {
        this._currentNode.content += &quot;\n&quot; + line;
    }
} else {
    if (typeof this._currentNode.content != &quot;string&quot;) {
        this._currentNode.content = line;
    } else if (this._currentNode.content.match(/[ ]$/)) {
        if (this._currentNode.meta.textFormat == &quot;flowed&quot; &amp;&amp; this._currentNode.content.match(/(^|\n)-- $/)) {
            // handle special case for usenet signatures
            this._currentNode.content += &quot;\n&quot; + line;
        } else {
            if (this._currentNode.meta.textDelSp == &quot;yes&quot;) {
                this._currentNode.content = this._currentNode.content.replace(/[ ]+$/, &quot;&quot;);
            }
            this._currentNode.content += line;
        }
    } else {
        this._currentNode.content += &quot;\n&quot; + line;
    }
}</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Processes a line in an attachment node&lt;/p&gt;

 &lt;p&gt;If a stream is set up for the attachment write the line to the
 stream as a Buffer object, otherwise append it to the content property&lt;/p&gt;

 @param {String} line A line to be processed
/</pre>

<p>MailParser.prototype._handleAttachmentLine = function(line) {</p>

<pre>if (!this._currentNode.attachment) {
    return;
}
if (this._currentNode.stream) {
    if (!this._currentNode.streamStarted) {
        this._currentNode.streamStarted = true;
        this._currentNode.stream.write(new Buffer(line, &quot;binary&quot;));
    } else {
        this._currentNode.stream.write(new Buffer(&quot;\r\n&quot; + line, &quot;binary&quot;));
    }
} else if (&quot;content&quot; in this._currentNode) {
    if (typeof this._currentNode.content != &quot;string&quot;) {
        this._currentNode.content = line;
    } else {
        this._currentNode.content += &quot;\r\n&quot; + line;
    }
}</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Finalizes a node processing&lt;/p&gt;

 &lt;p&gt;If the node is a text/plain or text/html, convert it to UTF-8 encoded string
 If it is an attachment, convert it to a Buffer or if an attachment stream is
 set up, close the stream&lt;/p&gt;
/</pre>

<p>MailParser.prototype._finalizeContents = function() {</p>

<pre>var streamInfo;

if (this._currentNode.content) {

    if (!this._currentNode.attachment) {

        if (this._currentNode.meta.contentType == &quot;text/html&quot; &amp;&amp; !this._currentNode.meta.charset) {
            this._currentNode.meta.charset = this._detectHTMLCharset(this._currentNode.content) || this.options.defaultCharset || &quot;iso-8859-1&quot;;
        }

        if (this._currentNode.meta.transferEncoding == &quot;quoted-printable&quot;) {
            this._currentNode.content = mimelib.decodeQuotedPrintable(this._currentNode.content, false, this._currentNode.meta.charset || this.options.defaultCharset || &quot;iso-8859-1&quot;);
            if (this._currentNode.meta.textFormat == &quot;flowed&quot;) {
                if (this._currentNode.meta.textDelSp == &quot;yes&quot;) {
                    this._currentNode.content = this._currentNode.content.replace(/(^|\n)-- \n/g, &#39;$1-- \u0000&#39;).replace(/ \n/g, &#39;&#39;).replace(/(^|\n)-- \u0000/g, &#39;$1-- \n&#39;);
                } else {
                    this._currentNode.content = this._currentNode.content.replace(/(^|\n)-- \n/g, &#39;$1-- \u0000&#39;).replace(/ \n/g, &#39; &#39;).replace(/(^|\n)-- \u0000/g, &#39;$1-- \n&#39;);
                }
            }
        } else if (this._currentNode.meta.transferEncoding == &quot;base64&quot;) {
            this._currentNode.content = mimelib.decodeBase64(this._currentNode.content, this._currentNode.meta.charset || this.options.defaultCharset || &quot;iso-8859-1&quot;);
        } else {
            this._currentNode.content = this._convertStringToUTF8(this._currentNode.content);
        }
    } else {
        if (this._currentNode.meta.transferEncoding == &quot;quoted-printable&quot;) {
            this._currentNode.content = mimelib.decodeQuotedPrintable(this._currentNode.content, false, &quot;binary&quot;);
        } else if (this._currentNode.meta.transferEncoding == &quot;base64&quot;) {

            // WTF? if newlines are not removed, the resulting hash is *always* different
            this._currentNode.content = new Buffer(this._currentNode.content.toString().replace(/\s+/g, &quot;&quot;), &quot;base64&quot;);

        } else if (this._currentNode.meta.transferEncoding == &quot;uuencode&quot;) {
            var uuestream = new Streams.UUEStream(&quot;binary&quot;);
            this._currentNode.content = uuestream.decode(new Buffer(this._currentNode.content, &quot;binary&quot;));
        } else {
            this._currentNode.content = new Buffer(this._currentNode.content, &quot;binary&quot;);
        }
        this._currentNode.checksum = crypto.createHash(&quot;md5&quot;);
        this._currentNode.checksum.update(this._currentNode.content);
        this._currentNode.meta.checksum = this._currentNode.checksum.digest(&quot;hex&quot;);
        this._currentNode.meta.length = this._currentNode.content.length;
    }

}

if (this._currentNode.stream) {
    streamInfo = this._currentNode.stream.end() || {};
    if (streamInfo.checksum) {
        this._currentNode.meta.checksum = streamInfo.checksum;
    }
    if (streamInfo.length) {
        this._currentNode.meta.length = streamInfo.length;
    }
}</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Processes the mime tree&lt;/p&gt;

 &lt;p&gt;Finds text parts and attachments from the tree. If there&#39;s several text/plain
 or text/html parts, join these into one&lt;/p&gt;

 &lt;p&gt;Emits &quot;end&quot; when finished&lt;/p&gt;
/</pre>

<p>MailParser.prototype._processMimeTree = function() {</p>

<pre>var returnValue = {},
    i, len;

this.mailData = {
    html: [],
    text: [],
    calendar: [],
    attachments: []
};

if (!this.mimeTree.meta.mimeMultipart) {
    this._processMimeNode(this.mimeTree, 0);
} else {
    this._walkMimeTree(this.mimeTree);
}

if (this.mailData.html.length) {
    for (i = 0, len = this.mailData.html.length; i &lt; len; i++) {
        if (!returnValue.html &amp;&amp; this.mailData.html[i].content) {
            returnValue.html = this.mailData.html[i].content;
        } else if (this.mailData.html[i].content) {
            returnValue.html = this._concatHTML(returnValue.html, this.mailData.html[i].content);
        }
    }
}

if (this.mailData.text.length) {
  var len = this.mailData.text.length;
  // if we have both html and text, process text till the length of html assuming its alternative for html
  if (this.mailData.html.length) {
    len = Math.min(len, this.mailData.html.length);
  }
  for (i = 0, len; i &lt; len; i++) {
    if (!returnValue.text &amp;&amp; this.mailData.text[i].content) {
      returnValue.text = this.mailData.text[i].content;
    } else if (this.mailData.text[i].content) {
      returnValue.text += this.mailData.text[i].content;
    }
  }
  // all remaining text contents if present assumed as additional content and concatenated with html as well as text
  for (len = this.mailData.text.length; i &lt; len; i++) {
    if (this.mailData.text[i].content) {
      // concatenate to both text and html so that text and html are always same content
      // user should be able to chose any one of them
      returnValue.text += this.mailData.text[i].content;
      returnValue.html += this.mailData.text[i].content;
    }
  }
}

if (this.mailData.calendar.length) {
    returnValue.alternatives = [];
    for (i = 0, len = this.mailData.calendar.length; i &lt; len; i++) {
        returnValue.alternatives.push(this.mailData.calendar[i].content);
    }
}

returnValue.headers = this.mimeTree.parsedHeaders;

if (this.mimeTree.subject) {
    returnValue.subject = this.mimeTree.subject;
}

if (this.mimeTree.references) {
    returnValue.references = this.mimeTree.references;
}

if (this.mimeTree.messageId) {
    returnValue.messageId = this.mimeTree.messageId;
}

if (this.mimeTree.inReplyTo) {
    returnValue.inReplyTo = this.mimeTree.inReplyTo;
}

if (this.mimeTree.priority) {
    returnValue.priority = this.mimeTree.priority;
}

if (this.mimeTree.from) {
    returnValue.from = this.mimeTree.from;
}

if (this.mimeTree.replyTo) {
    returnValue.replyTo = this.mimeTree.replyTo;
}

if (this.mimeTree.to) {
    returnValue.to = this.mimeTree.to;
}

if (this.mimeTree.cc) {
    returnValue.cc = this.mimeTree.cc;
}

if (this.mimeTree.bcc) {
    returnValue.bcc = this.mimeTree.bcc;
}

if (this.mimeTree.meta.date) {
    returnValue.date = this.mimeTree.meta.date;
}

if (this.mimeTree.meta.receivedDate) {
    returnValue.receivedDate = this.mimeTree.meta.receivedDate;
}

if (this.mailData.attachments.length) {
    returnValue.attachments = [];
    for (i = 0, len = this.mailData.attachments.length; i &lt; len; i++) {
        returnValue.attachments.push(this.mailData.attachments[i].content);
    }
}

if (typeof setImmediate == &quot;function&quot;) {
    setImmediate(this.emit.bind(this, &quot;end&quot;, returnValue));
} else {
    process.nextTick(this.emit.bind(this, &quot;end&quot;, returnValue));
}</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Walks the mime tree and runs processMimeNode on each node of the tree&lt;/p&gt;

 @param {Object} node A mime tree node
 @param {Number} [level=0] current depth
/</pre>

<p>MailParser.prototype._walkMimeTree = function(node, level) {</p>

<pre>level = level || 1;
for (var i = 0, len = node.childNodes.length; i &lt; len; i++) {
    this._processMimeNode(node.childNodes[i], level, node.meta.mimeMultipart);
    this._walkMimeTree(node.childNodes[i], level + 1);
}</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Processes of a node in the mime tree&lt;/p&gt;

 &lt;p&gt;Pushes the node into appropriate &lt;code&gt;this.mailData&lt;/code&gt; array (&lt;code&gt;text/html&lt;/code&gt; to &lt;code&gt;this.mailData.html&lt;/code&gt; array etc)&lt;/p&gt;

 @param {Object} node A mime tree node
 @param {Number} [level=0] current depth
 @param {String} mimeMultipart Type of multipart we are dealing with (if any)
/</pre>

<p>MailParser.prototype._processMimeNode = function(node, level,
mimeMultipart) {</p>

<pre>var i, len;

level = level || 0;

if (!node.attachment) {
    switch (node.meta.contentType) {
        case &quot;text/html&quot;:
            if (mimeMultipart == &quot;mixed&quot; &amp;&amp; this.mailData.html.length) {
                for (i = 0, len = this.mailData.html.length; i &lt; len; i++) {
                    if (this.mailData.html[i].level == level) {
                        this._joinHTMLNodes(this.mailData.html[i], node.content);
                        return;
                    }
                }
            }
            this.mailData.html.push({
                content: this._updateHTMLCharset(node.content || &quot;&quot;),
                level: level
            });
            return;
        case &quot;text/plain&quot;:
            this.mailData.text.push({
                content: node.content || &quot;&quot;,
                level: level
            });
            return;
        case &quot;text/calendar&quot;:
            if (node.content) {
                node.meta.content = node.content;
            }
            this.mailData.calendar.push({
                content: node.meta || {},
                level: level
            });
            return;
    }
} else {
    node.meta = node.meta || {};
    if (node.content) {
        node.meta.content = node.content;
    }
    this.mailData.attachments.push({
        content: node.meta || {},
        level: level
    });

    if (this.options.showAttachmentLinks &amp;&amp; mimeMultipart == &quot;mixed&quot; &amp;&amp; this.mailData.html.length) {
        for (i = 0, len = this.mailData.html.length; i &lt; len; i++) {
            if (this.mailData.html[i].level == level) {
                this._joinHTMLAttachment(this.mailData.html[i], node.meta);
                return;
            }
        }
    }
}</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Joins two HTML blocks by removing the header of the added element&lt;p&gt;

 @param {Object} htmlNode Original HTML contents node object
 @param {String} newHTML HTML text to add to the original object node
/</pre>

<p>MailParser.prototype._joinHTMLNodes = function(htmlNode, newHTML) {</p>

<pre>var inserted = false;

// process new HTML
newHTML = (newHTML || &quot;&quot;).toString(&quot;utf-8&quot;).trim();

// remove doctype from the beginning
newHTML = newHTML.replace(/^\s*&lt;\!doctype( [^&gt;]*)?&gt;/gi, &quot;&quot;);

// remove &lt;head&gt; and &lt;html&gt; blocks
newHTML = newHTML.replace(/&lt;head( [^&gt;]*)?&gt;(.*)&lt;\/head( [^&gt;]*)?&gt;/gi, &quot;&quot;).
replace(/&lt;\/?html( [^&gt;]*)?&gt;/gi, &quot;&quot;).
trim();

// keep only text between &lt;body&gt; tags (if &lt;body exists)
newHTML.replace(/&lt;body(?: [^&gt;]*)?&gt;(.*)&lt;\/body( [^&gt;]*)?&gt;/gi, function(match, body) {
    newHTML = body.trim();
});

htmlNode.content = (htmlNode.content || &quot;&quot;).toString(&quot;utf-8&quot;).trim();

htmlNode.content = htmlNode.content.replace(/&lt;\/body( [^&gt;]*)?&gt;/i, function(match) {
    inserted = true;
    return &quot;&lt;br/&gt;\n&quot; + newHTML + match;
});

if (!inserted) {
    htmlNode.content += &quot;&lt;br/&gt;\n&quot; + newHTML;
}</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Adds filename placeholder to the HTML if needed&lt;/p&gt;

 @param {Object} htmlNode Original HTML contents node object
 @param {String} attachment Attachment meta object
/</pre>

<p>MailParser.prototype._joinHTMLAttachment = function(htmlNode, attachment) {</p>

<pre>var inserted = false,
    fname = attachment.generatedFileName.replace(/&lt;/g, &quot;&amp;lt;&quot;).replace(/&gt;/g, &quot;&amp;gt;&quot;).replace(/&quot;/g, &quot;&amp;quot;&quot;),
    newHTML;

newHTML = &quot;\n&lt;div class=\&quot;mailparser-attachment\&quot;&gt;&lt;a href=\&quot;cid:&quot; + attachment.contentId + &quot;\&quot;&gt;&amp;lt;&quot; + fname + &quot;&amp;gt;&lt;/a&gt;&lt;/div&gt;&quot;;

htmlNode.content = (htmlNode.content || &quot;&quot;).toString(&quot;utf-8&quot;).trim();

htmlNode.content = htmlNode.content.replace(/&lt;\/body\b[^&gt;]*&gt;/i, function(match) {
    inserted = true;
    return &quot;&lt;br/&gt;\n&quot; + newHTML + match;
});

if (!inserted) {
    htmlNode.content += &quot;&lt;br/&gt;\n&quot; + newHTML;
}</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Joins two HTML blocks by removing the header of the added element&lt;p&gt;

 @param {Sting} htmlNode Original HTML contents
 @param {String} newHTML HTML text to add to the original object node
 @return {String} Joined HTML
/</pre>

<p>MailParser.prototype._concatHTML = function(firstNode, secondNode) {</p>

<pre>var headerNode = &quot;&quot;,
    htmlHeader = &quot;&quot;;

firstNode = (firstNode || &quot;&quot;).toString(&quot;utf-8&quot;);
secondNode = (secondNode || &quot;&quot;).toString(&quot;utf-8&quot;);

if (!secondNode) {
    return firstNode;
}
if (!firstNode) {
    return secondNode;
}

if (firstNode.substr(0, 1024).replace(/\r?\n/g, &quot;\u0000&quot;).match(/^[\s\u0000]*(&lt;\!doctype\b[^&gt;]*?&gt;)?[\s\u0000]*&lt;(html|head)\b[^&gt;]*?&gt;/i)) {
    headerNode = firstNode;
} else if (secondNode.substr(0, 1024).replace(/\r?\n/g, &quot;\u0000&quot;).match(/^[\s\u0000]*(&lt;\!doctype\b[^&gt;]*?&gt;)?[\s\u0000]*&lt;(html|head)\b[^&gt;]*?&gt;/i)) {
    headerNode = secondNode;
}

if (headerNode) {
    headerNode.replace(/\r?\n/g, &quot;\u0000&quot;).replace(/^[\s\u0000]*(&lt;\!doctype\b[^&gt;]*?&gt;)?[\s\u0000]*&lt;(html|head)\b[^&gt;]*&gt;.*?&lt;\/(head)\b[^&gt;]*&gt;(.*?&lt;body\b[^&gt;]*&gt;)?/i, function(h) {
        var doctype = h.match(/^[\s\u0000]*(&lt;\!doctype\b[^&gt;]*?&gt;)/i),
            html = h.match(/&lt;html\b[^&gt;]*?&gt;/i),
            head = h.match(/&lt;head\b[^&gt;]*?&gt;/i),
            body = h.match(/&lt;body\b[^&gt;]*?&gt;/i);

        doctype = doctype &amp;&amp; doctype[1] &amp;&amp; doctype[1] + &quot;\n&quot; || &quot;&quot;;
        html = html &amp;&amp; html[0] || &quot;&lt;head&gt;&quot;;
        head = head &amp;&amp; head[0] || &quot;&lt;head&gt;&quot;;
        body = body &amp;&amp; body[0] || &quot;&lt;body&gt;&quot;;
        h = h.replace(/&lt;[\!\/]?(doctype|html|head|body)\b[^&gt;]*?&gt;/ig, &quot;\u0000&quot;).replace(/\u0000+/g, &quot;\n&quot;).trim();

        htmlHeader = doctype + html + &quot;\n&quot; + head + (h ? h + &quot;\n&quot; : &quot;&quot;) + &quot;&lt;/head&gt;\n&quot; + body + &quot;\n&quot;;
    });
}

firstNode = firstNode.replace(/\r?\n/g, &quot;\u0000&quot;).
replace(/[\s\u0000]*&lt;head\b[^&gt;]*&gt;.*?&lt;\/(head|body)\b[^&gt;]*&gt;/gi, &quot;&quot;).
replace(/[\s\u0000]*&lt;[\!\/]?(doctype|html|body)\b[^&gt;]*&gt;[\s\u0000]*/gi, &quot;&quot;).
replace(/\u0000/g, &quot;\n&quot;);

secondNode = secondNode.replace(/\r?\n/g, &quot;\u0000&quot;).
replace(/[\s\u0000]*&lt;head\b[^&gt;]*&gt;.*?&lt;\/(head|body)\b[^&gt;]*&gt;/gi, &quot;&quot;).
replace(/[\s\u0000]*&lt;[\!\/]?(doctype|html|body)\b[^&gt;]*&gt;[\s\u0000]*/gi, &quot;&quot;).
replace(/\u0000/g, &quot;\n&quot;);

return htmlHeader + firstNode + secondNode + (htmlHeader ? (firstNode || secondNode ? &quot;\n&quot; : &quot;&quot;) + &quot;&lt;/body&gt;\n&lt;/html&gt;&quot; : &quot;&quot;);</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Converts a string from one charset to another&lt;/p&gt;

 @param {Buffer|String} value A String to be converted
 @param {String} fromCharset source charset
 @param {String} [toCharset=&quot;UTF-8&quot;] destination charset
 @returns {Buffer} Converted string as a Buffer (or SlowBuffer)
/</pre>

<p>MailParser.prototype._convertString = function(value, fromCharset,
toCharset) {</p>

<pre>toCharset = (toCharset || &quot;utf-8&quot;).toUpperCase();
fromCharset = (fromCharset || &quot;utf-8&quot;).toUpperCase();

value = typeof value == &quot;string&quot; ? new Buffer(value, &quot;binary&quot;) : value;

if (toCharset == fromCharset) {
    return value;
}

value = encodinglib.convert(value, toCharset, fromCharset);

return value;</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Converts a string to UTF-8&lt;/p&gt;

 @param {String} value String to be encoded
 @returns {String} UTF-8 encoded string
/</pre>

<p>MailParser.prototype._convertStringToUTF8 = function(value) {</p>

<pre class="ruby"><span class="ruby-identifier">value</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_convertString</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_currentNode</span>.<span class="ruby-identifier">meta</span>.<span class="ruby-identifier">charset</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">options</span>.<span class="ruby-identifier">defaultCharset</span> <span class="ruby-operator">||</span> <span class="ruby-string">&quot;iso-8859-1&quot;</span>).<span class="ruby-identifier">toString</span>(<span class="ruby-string">&quot;utf-8&quot;</span>);
<span class="ruby-keyword">return</span> <span class="ruby-identifier">value</span>;
</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Encodes a header string to UTF-8&lt;/p&gt;

 @param {String} value String to be encoded
 @returns {String} UTF-8 encoded string
/</pre>

<p>MailParser.prototype._encodeString = function(value) {</p>

<pre class="ruby"><span class="ruby-identifier">value</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">_replaceMimeWords</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">_convertStringToUTF8</span>(<span class="ruby-identifier">value</span>));
<span class="ruby-keyword">return</span> <span class="ruby-identifier">value</span>;
</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Replaces mime words in a string with UTF-8 encoded strings&lt;/p&gt;

 @param {String} value String to be converted
 @returns {String} converted string
/</pre>

<p>MailParser.prototype._replaceMimeWords = function(value) {</p>

<pre>return value.
replace(/(=\?[^?]+\?[QqBb]\?[^?]*\?=)\s+(?==\?[^?]+\?[QqBb]\?[^?]*\?=)/g, &quot;$1&quot;). // join mimeWords
replace(/\=\?[^?]+\?[QqBb]\?[^?]*\?=/g, (function(a) {
    return mimelib.decodeMimeWord(a.replace(/\s/g, &#39;&#39;));
}).bind(this));</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Removes enclosing quotes (&quot;&quot;, &#39;&#39;, &amp;lt;&amp;gt;) from a string&lt;/p&gt;

 @param {String} value String to be converted
 @returns {String} converted string
/</pre>

<p>MailParser.prototype._trimQuotes = function(value) {</p>

<pre>value = (value || &quot;&quot;).trim();
if ((value.charAt(0) == &#39;&quot;&#39; &amp;&amp; value.charAt(value.length - 1) == &#39;&quot;&#39;) ||
    (value.charAt(0) == &quot;&#39;&quot; &amp;&amp; value.charAt(value.length - 1) == &quot;&#39;&quot;) ||
    (value.charAt(0) == &quot;&lt;&quot; &amp;&amp; value.charAt(value.length - 1) == &quot;&gt;&quot;)) {
    value = value.substr(1, value.length - 2);
}
return value;</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Generates a context unique filename for an attachment&lt;/p&gt;

 &lt;p&gt;If a filename already exists, append a number to it&lt;/p&gt;

 &lt;ul&gt;
     &lt;li&gt;file.txt&lt;/li&gt;
     &lt;li&gt;file-1.txt&lt;/li&gt;
     &lt;li&gt;file-2.txt&lt;/li&gt;
 &lt;/ul&gt;

 @param {String} fileName source filename
 @param {String} contentType source content type
 @returns {String} generated filename
/</pre>

<p>MailParser.prototype._generateFileName = function(fileName, contentType) {</p>

<pre>var ext, defaultExt = &quot;&quot;,
    fileRootName;

if (contentType) {
    defaultExt = mime.extension(contentType);
    defaultExt = defaultExt ? &quot;.&quot; + defaultExt : &quot;&quot;;
}

fileName = fileName || &quot;attachment&quot; + defaultExt;

// remove path if it is included in the filename
fileName = fileName.toString().split(/[\/\\]+/).pop().replace(/^\.+/, &quot;&quot;) || &quot;attachment&quot;;
fileRootName = fileName.replace(/(?:\-\d+)+(\.[^.]*)$/, &quot;$1&quot;) || &quot;attachment&quot;;

if (fileRootName in this._fileNames) {
    this._fileNames[fileRootName]++;
    ext = fileName.substr((fileName.lastIndexOf(&quot;.&quot;) || 0) + 1);
    if (ext == fileName) {
        fileName += &quot;-&quot; + this._fileNames[fileRootName];
    } else {
        fileName = fileName.substr(0, fileName.length - ext.length - 1) + &quot;-&quot; + this._fileNames[fileRootName] + &quot;.&quot; + ext;
    }
} else {
    this._fileNames[fileRootName] = 0;
}

return fileName;</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Replaces character set to UTF-8 in HTML &amp;lt;meta&amp;gt; tags&lt;/p&gt;

 @param {String} HTML html contents
 @returns {String} updated HTML
/</pre>

<p>MailParser.prototype._updateHTMLCharset = function(html) {</p>

<pre>html = html.replace(/\n/g, &quot;\u0000&quot;).
replace(/&lt;meta[^&gt;]*&gt;/gi, function(meta) {
    if (meta.match(/http\-equiv\s*=\s*&quot;?content\-type/i)) {
        return &#39;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&#39;;
    }
    if (meta.match(/\scharset\s*=\s*[&#39;&quot;]?[\w\-]+[&quot;&#39;\s&gt;\/]/i)) {
        return &#39;&lt;meta charset=&quot;utf-8&quot;/&gt;&#39;;
    }
    return meta;
}).
replace(/\u0000/g, &quot;\n&quot;);

return html;</pre>

<p>};</p>

<p>/**</p>

<pre> &lt;p&gt;Detects the charset of an HTML file&lt;/p&gt;

 @param {String} HTML html contents
 @returns {String} Charset for the HTML
/</pre>

<p>MailParser.prototype._detectHTMLCharset = function(html) {</p>

<pre>var charset, input, meta;

if (typeof html != &quot;string&quot;) {
    html = html.toString(&quot;ascii&quot;);
}

if ((meta = html.match(/&lt;meta\s+http-equiv=[&quot;&#39;]content-type[&quot;&#39;][^&gt;]*?&gt;/i))) {
    input = meta[0];
}

if (input) {
    charset = input.match(/charset\s?=\s?([a-zA-Z\-_:0-9]*);?/);
    if (charset) {
        charset = (charset[1] || &quot;&quot;).trim().toLowerCase();
    }
}

if (!charset &amp;&amp; (meta = html.match(/&lt;meta\s+charset=[&quot;&#39;]([^&#39;&quot;&lt;\/]*?)[&quot;&#39;]/i))) {
    charset = (meta[1] || &quot;&quot;).trim().toLowerCase();
}

return charset;</pre>

<p>};</p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://rdoc.github.io/rdoc">RDoc</a> 5.0.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

